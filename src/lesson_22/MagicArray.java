package lesson_22;

import java.util.Arrays;

public class MagicArray {

    int[] array;
    int cursor; // по умолчанию значение = 0

    // методы расширяющие функционал массива

    public MagicArray() {
        this.array = new int[10]; // [0, 0, ...0]
    }

    public MagicArray(int[] array) {
        //  Todo Homework
    }

    // Добавление в массив одного элемента
    void add(int value) {
        // нужна проверка есть ли свободное место во внутреннем массиве
        // если места нет то нужно его добавить
        if (cursor == array.length) {
            // нужно расширить внутренний массив перед добавлением нового значения
            expandArray();
        }

        array[cursor] = value;
        cursor++;
    }

    // Динамическое расширение массива
    void expandArray() {
        System.out.println("Расширяем массив ");
        /*
        1. Создать новый массив большего размера (например в 2 раза больше чем был)
        2. Переписать в новый массив все значения из старого (до курсора)
        3. Перебросить ссылку
         */

        // 1
        int[] newArray = new int[array.length * 2];

        // 2
        for (int i = 0; i < cursor; i++) {
            newArray[i] = array[i];
        }

        // 3
        array = newArray;


    }

    // Добавление в массив нескольких элементов
    void add(int... numbers) {
        // с numbers я могу обращаться точно так же как со ссылкой на массив интов
//      System.out.println("Принял несколько интов: " + numbers.length);
//      System.out.println(Arrays.toString(numbers));
//      System.out.println("У каждого инта есть индекс как в массиве" + numbers[0]);

        // перебираю все значения. Для каждого вызываю метод add()
        for (int i = 0; i < numbers.length; i++) {
            add(numbers[i]);
        }

    }

    // возвращаем строковое представление массива
    public String toString() {

        if (cursor == 0) return "[]";

        String result = "[";
        for (int i = 0; i < cursor; i++) {
            result += array[i] + (i < cursor - 1 ? ", " : "]");
        }

        return result;
    }

    // текущее количество элементов в массиве
    int size() {
        return cursor;
    }

    // Возвращает значение по индексу
    int get(int index) {

        // проконтролировать входящий индекс
        if (index >= 0 && index < cursor) {
            return  array[index];
        }

        // код если индекс не корректный
        // хорошего решения нет
        return -2_147_483_647;
        // Todo Поправить обработку некорректного индекса
        // какие еще комментарии:
        // Fixme исправить код
    }

    // Удаление элемента по индексу
    int remove(int index) {
        /*
        1. Проверить индекс на валидность
        2. Удалить значение по индексу
        3. Передвинуть курсор (тк количество эл уменшилось)
        4. вернуть старое значение
         */
        if (index >= 0 && index < cursor) {
            // логика удаления
            int value = array[index]; // запомнить старое значение

            // перебираем элемент начиная с индекса
            // и перезаписываем значание из ячейки справа
            for (int i= index; i < cursor - 1; i++) {
                array[i] = array[i + 1];
            }

            cursor--;


            return value; // вернуть старое значение
        } else {
            // индекс не валидный
            // Todo поправить возвращаемое значение
            return -2_147_483_647;
        }

    }

    // Поиск по значению
    // {1,100,5,0} -> indexOf(5) = 1; indexOf(50) = -1;(несуществующий индекс)
    int indexOf(int value) {
        // перебираю все значимые элементы
        // если элемент равен искомому -  вернуть индекс такого элемента
        // если перебрал все и не нашел совпадений - вернуть -1

        for (int i = 0; i < cursor; i++) {
            if (array[i] == value) {
                //значения совпали - возвращаем индекс
                return  i;
            }
        }
        // сюда попадем если ни одно значение не совпало
        return -1;
    }

    // индекс последнего вхождения
    // {1,100,5,100,24,0,100} -> lastIndexOf(100) -> 6-й
    int lastIndexOf(int value) {
        // Todo Homework
        return -1;

    }

    // удалить элемент по значению
    boolean removeByValue(int value) {
        //Todo Homework
        return false;
    }




    void test() {
        System.out.println(Arrays.toString(array));
    }


}

/*
1. Хочу добавлять в массив элемент (не думая об индексах, размере массива)
2. Динамическое изменение размера внутреннего массива
3. Возвратить строковое представление массива (Вывести на экран все элементы массива (какие элементы есть)
4. Добавить в массив сразу несколько значений
5. Текущее колич-во эл в массиве
6. Возвращать значение по индексу
7. Удалить элемент по индексу ( есть индекс - удачить элемент из масива)
8. удалить элемент по значению. Возвращал boolean. Если удалил вернут true , если не нашел вернут false
9. Поиск по значению. Возвращать индекс первого вхождения элемента
10. индекс последнего вхождения
11. Конструктор, принимающий обычный массив. Создать магический массив с элементами из этого массива
 */
